// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: recipe.sql

package repository

import (
	"context"

	"github.com/miloszbo/meals-finder/internal/models"
)

const addTagsForRecipe = `-- name: AddTagsForRecipe :exec
INSERT INTO recipes_tags (recipe_id, tag_id) VALUES
($1::int, $2::int)
`

type AddTagsForRecipeParams struct {
	RecipeID int32 `json:"recipe_id"`
	TagID    int32 `json:"tag_id"`
}

func (q *Queries) AddTagsForRecipe(ctx context.Context, arg AddTagsForRecipeParams) error {
	_, err := q.db.Exec(ctx, addTagsForRecipe, arg.RecipeID, arg.TagID)
	return err
}

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO recipes (name,recipe,ingredients,time,difficulty) VALUES 
(
  $1::text,
  $2::text,
  $3,
  $4::int,
  $5::int
) RETURNING id
`

type CreateRecipeParams struct {
	Name        string                 `json:"name"`
	Recipe      string                 `json:"recipe"`
	Ingredients models.IngredientsJson `json:"ingredients"`
	Time        int32                  `json:"time"`
	Difficulty  int32                  `json:"difficulty"`
}

func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (int32, error) {
	row := q.db.QueryRow(ctx, createRecipe,
		arg.Name,
		arg.Recipe,
		arg.Ingredients,
		arg.Time,
		arg.Difficulty,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const filterRecipesByTagNamesAndParams = `-- name: FilterRecipesByTagNamesAndParams :many
SELECT r.id, r.name, r.time, r.difficulty
FROM recipes r
WHERE
  -- User tags
  (NOT EXISTS (SELECT 1 FROM users_tags ut WHERE ut.username = $1::text) OR

  EXISTS (SELECT 1 FROM recipes_tags rt JOIN users_tags ut ON rt.tag_id = ut.tag_id WHERE
  ut.username = $1::text AND rt.recipe_id = r.id AND rt.tag_id IN (SELECT tag_id FROM users_tags ut WHERE ut.username = $1::text)))

  -- Min preparation time (optional)
  AND ($2::int = 0 OR r.time >= $2::int)

  -- Max preparation time (optional)
  AND ($3::int = 0 OR r.time <= $3::int)

  -- Min difficulty (optional)
  AND ($4::int = 0 OR r.difficulty >= $4::int)

  -- Max difficulty (optional)
  AND ($5::int = 0 OR r.difficulty <= $5::int)

  -- Type 1 (Dieta): OR within, AND across types
  AND ($6::text[] IS NULL OR EXISTS (
    SELECT 1 FROM recipes_tags rt
    JOIN tags t ON t.id = rt.tag_id
    WHERE rt.recipe_id = r.id
      AND t.type_id = 1
      AND t.name = ANY($6::text[])
  ))

  -- Type 2 (Region)
  AND ($7::text[] IS NULL OR EXISTS (
    SELECT 1 FROM recipes_tags rt
    JOIN tags t ON t.id = rt.tag_id
    WHERE rt.recipe_id = r.id
      AND t.type_id = 2
      AND t.name = ANY($7::text[])
  ))

  -- Type 3 (Rodzaj)
  AND ($8::text[] IS NULL OR EXISTS (
    SELECT 1 FROM recipes_tags rt
    JOIN tags t ON t.id = rt.tag_id
    WHERE rt.recipe_id = r.id
      AND t.type_id = 3
      AND t.name = ANY($8::text[])
  ))

  -- Type 4 (Alergie): must NOT include any of these
  AND ($9::text[] IS NULL OR NOT EXISTS (
    SELECT 1 FROM recipes_tags rt
    JOIN tags t ON t.id = rt.tag_id
    WHERE rt.recipe_id = r.id
      AND t.type_id = 4
      AND t.name = ANY($9::text[])
  ))

  -- Type 5 (Składniki odżywcze)
  AND ($10::text[] IS NULL OR EXISTS (
    SELECT 1 FROM recipes_tags rt
    JOIN tags t ON t.id = rt.tag_id
    WHERE rt.recipe_id = r.id
      AND t.type_id = 5
      AND t.name = ANY($10::text[])
  ))

  -- Type 6 (Inne)
  AND ($11::text[] IS NULL OR EXISTS (
    SELECT 1 FROM recipes_tags rt
    JOIN tags t ON t.id = rt.tag_id
    WHERE rt.recipe_id = r.id
      AND t.type_id = 6
      AND t.name = ANY($11::text[])
  ))

ORDER BY r.id LIMIT $13::int OFFSET $12::int
`

type FilterRecipesByTagNamesAndParamsParams struct {
	Username      string   `json:"username"`
	MinTime       int32    `json:"min_time"`
	MaxTime       int32    `json:"max_time"`
	MinDifficulty int32    `json:"min_difficulty"`
	MaxDifficulty int32    `json:"max_difficulty"`
	Diet          []string `json:"diet"`
	Region        []string `json:"region"`
	RecipeType    []string `json:"recipe_type"`
	Allergies     []string `json:"allergies"`
	Nutrients     []string `json:"nutrients"`
	Others        []string `json:"others"`
	RecipesOffset int32    `json:"recipes_offset"`
	RecipesLimit  int32    `json:"recipes_limit"`
}

type FilterRecipesByTagNamesAndParamsRow struct {
	ID         int32  `json:"id"`
	Name       string `json:"name"`
	Time       int32  `json:"time"`
	Difficulty int32  `json:"difficulty"`
}

func (q *Queries) FilterRecipesByTagNamesAndParams(ctx context.Context, arg FilterRecipesByTagNamesAndParamsParams) ([]FilterRecipesByTagNamesAndParamsRow, error) {
	rows, err := q.db.Query(ctx, filterRecipesByTagNamesAndParams,
		arg.Username,
		arg.MinTime,
		arg.MaxTime,
		arg.MinDifficulty,
		arg.MaxDifficulty,
		arg.Diet,
		arg.Region,
		arg.RecipeType,
		arg.Allergies,
		arg.Nutrients,
		arg.Others,
		arg.RecipesOffset,
		arg.RecipesLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterRecipesByTagNamesAndParamsRow
	for rows.Next() {
		var i FilterRecipesByTagNamesAndParamsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Time,
			&i.Difficulty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTags = `-- name: GetAllTags :many
SELECT tt.name AS type_name, t.name AS tag_name
FROM tags t
JOIN tags_types tt ON t.type_id = tt.id
ORDER BY tt.id, t.name
`

type GetAllTagsRow struct {
	TypeName string `json:"type_name"`
	TagName  string `json:"tag_name"`
}

func (q *Queries) GetAllTags(ctx context.Context) ([]GetAllTagsRow, error) {
	rows, err := q.db.Query(ctx, getAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTagsRow
	for rows.Next() {
		var i GetAllTagsRow
		if err := rows.Scan(&i.TypeName, &i.TagName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipeWithId = `-- name: GetRecipeWithId :one
SELECT id, name, recipe, ingredients, time, difficulty, username FROM recipes WHERE id = $1
`

func (q *Queries) GetRecipeWithId(ctx context.Context, id int32) (Recipe, error) {
	row := q.db.QueryRow(ctx, getRecipeWithId, id)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Recipe,
		&i.Ingredients,
		&i.Time,
		&i.Difficulty,
		&i.Username,
	)
	return i, err
}

const getTagId = `-- name: GetTagId :one
SELECT t.id AS tag_id
FROM tags t WHERE t.name = $1::text
`

func (q *Queries) GetTagId(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, getTagId, name)
	var tag_id int32
	err := row.Scan(&tag_id)
	return tag_id, err
}
