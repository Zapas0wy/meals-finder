// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: recipe.sql

package repository

import (
	"context"
)

const filterRecipesByTagNamesAndParams = `-- name: FilterRecipesByTagNamesAndParams :many
SELECT r.name, r.synopsis, r.time, r.difficulty
FROM recipes r
WHERE
  -- Min preparation time (optional)
  ($7 = 0 OR r.time >= $7)

  -- Max preparation time (optional)
  AND ($8 = 0 OR r.time <= $8)

  -- Min difficulty (optional)
  AND ($9 = 0 OR r.difficulty >= $9)

  -- Max difficulty (optional)
  AND ($10 = 0 OR r.difficulty <= $10)

  -- Type 1 (Dieta): OR within, AND across types
  AND ($1::text[] IS NULL OR EXISTS (
    SELECT 1 FROM recipes_tags rt
    JOIN tags t ON t.id = rt.tag_id
    WHERE rt.recipe_id = r.id
      AND t.type_id = 1
      AND t.name = ANY($1)
  ))

  -- Type 2 (Region)
  AND ($2::text[] IS NULL OR EXISTS (
    SELECT 1 FROM recipes_tags rt
    JOIN tags t ON t.id = rt.tag_id
    WHERE rt.recipe_id = r.id
      AND t.type_id = 2
      AND t.name = ANY($2)
  ))

  -- Type 3 (Rodzaj)
  AND ($3::text[] IS NULL OR EXISTS (
    SELECT 1 FROM recipes_tags rt
    JOIN tags t ON t.id = rt.tag_id
    WHERE rt.recipe_id = r.id
      AND t.type_id = 3
      AND t.name = ANY($3)
  ))

  -- Type 4 (Alergie): must NOT include any of these
  AND ($4::text[] IS NULL OR NOT EXISTS (
    SELECT 1 FROM recipes_tags rt
    JOIN tags t ON t.id = rt.tag_id
    WHERE rt.recipe_id = r.id
      AND t.type_id = 4
      AND t.name = ANY($4)
  ))

  -- Type 5 (Składniki_odżywcze)
  AND ($5::text[] IS NULL OR EXISTS (
    SELECT 1 FROM recipes_tags rt
    JOIN tags t ON t.id = rt.tag_id
    WHERE rt.recipe_id = r.id
      AND t.type_id = 5
      AND t.name = ANY($5)
  ))

  -- Type 6 (Inne)
  AND ($6::text[] IS NULL OR EXISTS (
    SELECT 1 FROM recipes_tags rt
    JOIN tags t ON t.id = rt.tag_id
    WHERE rt.recipe_id = r.id
      AND t.type_id = 6
      AND t.name = ANY($6)
  ))

ORDER BY r.id
`

type FilterRecipesByTagNamesAndParamsParams struct {
	Column1  []string    `json:"column_1"`
	Column2  []string    `json:"column_2"`
	Column3  []string    `json:"column_3"`
	Column4  []string    `json:"column_4"`
	Column5  []string    `json:"column_5"`
	Column6  []string    `json:"column_6"`
	Column7  interface{} `json:"column_7"`
	Column8  interface{} `json:"column_8"`
	Column9  interface{} `json:"column_9"`
	Column10 interface{} `json:"column_10"`
}

type FilterRecipesByTagNamesAndParamsRow struct {
	Name       string `json:"name"`
	Synopsis   string `json:"synopsis"`
	Time       int32  `json:"time"`
	Difficulty int32  `json:"difficulty"`
}

func (q *Queries) FilterRecipesByTagNamesAndParams(ctx context.Context, arg FilterRecipesByTagNamesAndParamsParams) ([]FilterRecipesByTagNamesAndParamsRow, error) {
	rows, err := q.db.Query(ctx, filterRecipesByTagNamesAndParams,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Column10,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterRecipesByTagNamesAndParamsRow
	for rows.Next() {
		var i FilterRecipesByTagNamesAndParamsRow
		if err := rows.Scan(
			&i.Name,
			&i.Synopsis,
			&i.Time,
			&i.Difficulty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
